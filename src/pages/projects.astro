---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

const pageTitle = 'Projects';

const dateFormatter = new Intl.DateTimeFormat('en-US', {
  month: 'short',
  day: 'numeric',
  year: 'numeric',
});

const difficultyClass: Record<'Novice' | 'Adept' | 'Archmage', string> = {
  Novice: 'border-[color:var(--line)] text-[color:var(--metal-silver)]',
  Adept: 'border-[color:var(--accent)] text-[color:var(--accent)]',
  Archmage: 'border-[color:var(--metal-gold)] text-[color:var(--metal-gold)]',
};

const spells = (await getCollection('spells')).sort((a, b) => {
  const featured = Number(b.data.featured) - Number(a.data.featured);
  if (featured !== 0) return featured;
  return b.data.publishedAt.getTime() - a.data.publishedAt.getTime();
});

const availableTags = Array.from(new Set(spells.flatMap((spell) => spell.data.stack))).sort((a, b) =>
  a.localeCompare(b),
);
---
<BaseLayout pageTitle={pageTitle}>
  <section class="mx-auto max-w-6xl space-y-8">
    <header class="grimoire-card hero-glow p-6 md:p-8">
      <p class="section-title">Spell Index</p>
      <h2 class="mt-3 text-4xl font-semibold tracking-tight md:text-5xl">Projects as Spells</h2>
      <p class="mt-4 max-w-3xl leading-relaxed text-[color:var(--muted)]">
        Each entry captures a practical engineering spell: the problem it addressed, the approach, and what changed after.
      </p>
    </header>

    {spells.length === 0 ? (
      <div class="grimoire-card p-6">
        <p class="text-sm text-[color:var(--muted)]">No spells have been published yet.</p>
      </div>
    ) : (
      <div class="space-y-4">
        <div class="grimoire-card p-4">
          <p class="section-title">Filter by Tag</p>
          <p class="mt-2 text-xs uppercase tracking-[0.08em] text-[color:var(--muted)]">
            Select one or more tags
          </p>
          <div class="mt-3 flex flex-wrap gap-2" id="tag-filters">
            <button
              type="button"
              data-tag-filter="all"
              aria-pressed="true"
              class="sigil-badge sigil-badge-active"
            >
              All
            </button>
            {availableTags.map((tag) => (
              <button type="button" data-tag-filter={tag} aria-pressed="false" class="sigil-badge">
                {tag}
              </button>
            ))}
          </div>
        </div>

        <div class="grid grid-cols-1 gap-4 lg:grid-cols-2" id="spells-grid">
          {spells.map((spell) => (
            <a
              href={`/projects/${spell.slug}`}
              class="grimoire-card lift-on-hover block p-6"
              data-spell-card
              data-tags={spell.data.stack.map((item) => item.toLowerCase()).join('|')}
            >
              <div class="flex flex-wrap items-center gap-2">
                <span class={`sigil-badge ${difficultyClass[spell.data.difficulty]}`}>{spell.data.difficulty}</span>
                <span class="sigil-badge">{spell.data.domain}</span>
                <span class="sigil-badge">{spell.data.status}</span>
              </div>
              <h3 class="mt-4 text-2xl font-semibold">{spell.data.title}</h3>
              <p class="mt-2 text-sm leading-relaxed text-[color:var(--muted)]">{spell.data.summary}</p>
              <p class="mt-4 text-xs uppercase tracking-[0.1em] text-[color:var(--muted)]">
                {dateFormatter.format(spell.data.publishedAt)}
              </p>
              <div class="mt-3 flex flex-wrap gap-2">
                {spell.data.stack.map((item) => (
                  <span class="sigil-badge">{item}</span>
                ))}
              </div>
            </a>
          ))}
        </div>
        <p id="active-filter-summary" class="hidden text-xs uppercase tracking-[0.08em] text-[color:var(--muted)]">
          Showing all tags
        </p>
        <p id="no-filter-results" class="hidden text-sm text-[color:var(--muted)]">
          No spells match the selected tags.
        </p>
      </div>
    )}
  </section>
</BaseLayout>

<script is:inline>
  (() => {
    const ACTIVE_CLASS = 'sigil-badge-active';
    const filterButtons = Array.from(document.querySelectorAll('[data-tag-filter]'));
    const spellCards = Array.from(document.querySelectorAll('[data-spell-card]'));
    const summary = document.getElementById('active-filter-summary');
    const noResults = document.getElementById('no-filter-results');

    if (filterButtons.length === 0 || spellCards.length === 0) return;

    const allButton = filterButtons.find((button) => button.dataset.tagFilter === 'all');
    const tagButtons = filterButtons.filter((button) => button.dataset.tagFilter !== 'all');
    const selectedTags = new Set();

    const updateQueryParams = () => {
      const url = new URL(window.location.href);
      if (selectedTags.size === 0) {
        url.searchParams.delete('tags');
      } else {
        const tagValues = tagButtons
          .map((button) => button.dataset.tagFilter || '')
          .filter((tag) => selectedTags.has(tag.toLowerCase()));
        url.searchParams.set('tags', tagValues.join(','));
      }
      window.history.replaceState({}, '', `${url.pathname}${url.search}${url.hash}`);
    };

    const setActiveButtons = () => {
      for (const button of filterButtons) {
        const tag = button.dataset.tagFilter || '';
        const isActive = tag === 'all' ? selectedTags.size === 0 : selectedTags.has(tag.toLowerCase());
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        button.classList.toggle(ACTIVE_CLASS, isActive);
      }
    };

    const applyFilter = () => {
      let visibleCount = 0;
      for (const card of spellCards) {
        const rawTags = card.getAttribute('data-tags') || '';
        const tags = new Set(rawTags.split('|').filter(Boolean));
        const isVisible =
          selectedTags.size === 0 || Array.from(selectedTags).some((selectedTag) => tags.has(selectedTag));
        card.classList.toggle('hidden', !isVisible);
        if (isVisible) visibleCount += 1;
      }
      noResults?.classList.toggle('hidden', visibleCount !== 0);
      setActiveButtons();
      if (summary) {
        if (selectedTags.size === 0) {
          summary.classList.add('hidden');
        } else {
          const activeLabels = tagButtons
            .map((button) => button.dataset.tagFilter || '')
            .filter((tag) => selectedTags.has(tag.toLowerCase()));
          summary.textContent = `Showing tags: ${activeLabels.join(', ')}`;
          summary.classList.remove('hidden');
        }
      }
      updateQueryParams();
    };

    const applyInitialTagsFromUrl = () => {
      const url = new URL(window.location.href);
      const tagsParam = url.searchParams.get('tags');
      if (!tagsParam) return;

      const requested = tagsParam
        .split(',')
        .map((tag) => tag.trim().toLowerCase())
        .filter(Boolean);

      const available = new Set(tagButtons.map((button) => (button.dataset.tagFilter || '').toLowerCase()));
      for (const tag of requested) {
        if (available.has(tag)) selectedTags.add(tag);
      }
    };

    applyInitialTagsFromUrl();
    applyFilter();

    allButton?.addEventListener('click', () => {
      selectedTags.clear();
      applyFilter();
    });

    for (const button of tagButtons) {
      button.addEventListener('click', () => {
        const tag = (button.dataset.tagFilter || '').toLowerCase();
        if (!tag) return;
        if (selectedTags.has(tag)) {
          selectedTags.delete(tag);
        } else {
          selectedTags.add(tag);
        }
        applyFilter();
      });
    }
  })();
</script>
